name: üîç Wesley + SHA-lock HOLMES CI

on:
  pull_request:
    types: [opened, synchronize, reopened]
  push:
    branches: [main]

env:
  HOLMES_BUNDLE_DIR: example/.wesley
  HOLMES_SCHEMA: example/ecommerce.graphql
  HOLMES_SCHEMA_DIR: example
  HOLMES_OPS_DIR: ./ops
  HOLMES_OUT_DIR: out
  HOLMES_ARTIFACT: wesley-bundle

jobs:
  wesley-generate:
    name: "üöÄ Wesley Generation"
    runs-on: ubuntu-latest
    
    steps:
      - name: "üì¶ Checkout Repository"
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: "üõ†Ô∏è Setup HOLMES environment"
        uses: ./.github/actions/holmes-setup
        with:
          bundle-dir: ${{ env.HOLMES_BUNDLE_DIR }}
          schema: ${{ env.HOLMES_SCHEMA }}
          ops-dir: ${{ env.HOLMES_OPS_DIR }}
          out-dir: ${{ env.HOLMES_OUT_DIR }}
          artifact-name: ${{ env.HOLMES_ARTIFACT }}
          always-generate: 'true'
        
      - name: "üìä Display Scores"
        run: |
          echo "## üìä Generation Scores"
          if [ -f $HOLMES_BUNDLE_DIR/scores.json ]; then
            cat $HOLMES_BUNDLE_DIR/scores.json | jq '.scores'
          else
            echo "No scores.json found yet"
          fi
          
      - name: "üì¶ Prepare Bundle for Upload"
        run: |
          ls -la $HOLMES_BUNDLE_DIR
          test -f "$HOLMES_BUNDLE_DIR/bundle.json"

      - name: "üíæ Upload Bundle"
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.HOLMES_ARTIFACT }}
          path: |
            ${{ env.HOLMES_BUNDLE_DIR }}/bundle.json
            ${{ env.HOLMES_BUNDLE_DIR }}/scores.json
            ${{ env.HOLMES_BUNDLE_DIR }}/history.json
          
  holmes-investigate:
    name: "üîç HOLMES Investigation"
    runs-on: ubuntu-latest
    needs: wesley-generate
    
    steps:
      - name: "üì¶ Checkout Repository"
        uses: actions/checkout@v4
      
      - name: "üõ†Ô∏è Setup HOLMES environment"
        uses: ./.github/actions/holmes-setup
        with:
          bundle-dir: ${{ env.HOLMES_BUNDLE_DIR }}
          schema: ${{ env.HOLMES_SCHEMA }}
          ops-dir: ${{ env.HOLMES_OPS_DIR }}
          out-dir: ${{ env.HOLMES_OUT_DIR }}
          artifact-name: ${{ env.HOLMES_ARTIFACT }}
          
      - name: "üîç Run Investigation"
        id: holmes
        run: |
          cd "$(dirname "${HOLMES_SCHEMA}")"
          # Run HOLMES from workspace package
          node ../packages/wesley-holmes/src/cli.mjs investigate > holmes-report.md
          cat holmes-report.md
          cd - >/dev/null
          
      - name: "üíæ Save Report"
        uses: actions/upload-artifact@v4
        with:
          name: holmes-report
          path: ${{ env.HOLMES_SCHEMA_DIR }}/holmes-report.md
          
  watson-verify:
    name: "ü©∫ WATSON Verification"
    runs-on: ubuntu-latest
    needs: holmes-investigate
    
    steps:
      - name: "üì¶ Checkout Repository"
        uses: actions/checkout@v4
        
      - name: "üõ†Ô∏è Setup HOLMES environment"
        uses: ./.github/actions/holmes-setup
        with:
          bundle-dir: ${{ env.HOLMES_BUNDLE_DIR }}
          schema: ${{ env.HOLMES_SCHEMA }}
          ops-dir: ${{ env.HOLMES_OPS_DIR }}
          out-dir: ${{ env.HOLMES_OUT_DIR }}
          artifact-name: ${{ env.HOLMES_ARTIFACT }}
          
      - name: "ü©∫ Run Verification"
        id: watson
        run: |
          cd "$(dirname "${HOLMES_SCHEMA}")"
          node ../packages/wesley-holmes/src/cli.mjs verify > watson-report.md
          cat watson-report.md
          cd - >/dev/null
          
      - name: "üíæ Save Report"
        uses: actions/upload-artifact@v4
        with:
          name: watson-report
          path: ${{ env.HOLMES_SCHEMA_DIR }}/watson-report.md
          
  moriarty-predict:
    name: "üîÆ MORIARTY Predictions"
    runs-on: ubuntu-latest
    needs: watson-verify
    
    steps:
      - name: "üì¶ Checkout Repository"
        uses: actions/checkout@v4
        
      - name: "üõ†Ô∏è Setup HOLMES environment"
        uses: ./.github/actions/holmes-setup
        with:
          bundle-dir: ${{ env.HOLMES_BUNDLE_DIR }}
          schema: ${{ env.HOLMES_SCHEMA }}
          ops-dir: ${{ env.HOLMES_OPS_DIR }}
          out-dir: ${{ env.HOLMES_OUT_DIR }}
          artifact-name: ${{ env.HOLMES_ARTIFACT }}
          always-generate: 'true'
          
      - name: "üîÆ Run Predictions"
        id: moriarty
        run: |
          cd "$(dirname "${HOLMES_SCHEMA}")"
          node ../packages/wesley-holmes/src/cli.mjs predict > moriarty-report.md || echo "Insufficient data for predictions" > moriarty-report.md
          cat moriarty-report.md
          cd - >/dev/null
          
      - name: "üíæ Save Report"
        uses: actions/upload-artifact@v4
        with:
          name: moriarty-report
          path: ${{ env.HOLMES_SCHEMA_DIR }}/moriarty-report.md
          
  test-pgtap:
    name: "üß™ pgTAP Tests"
    runs-on: ubuntu-latest
    needs: wesley-generate
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
          
    steps:
      - name: "üì¶ Checkout Repository"
        uses: actions/checkout@v4
        
      - name: "üîß Setup pnpm"
        uses: pnpm/action-setup@v4

      - name: "üîß Setup Node.js"
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'

      - name: "üõ†Ô∏è Setup HOLMES environment"
        uses: ./.github/actions/holmes-setup
        with:
          bundle-dir: ${{ env.HOLMES_BUNDLE_DIR }}
          schema: ${{ env.HOLMES_SCHEMA }}
          ops-dir: ${{ env.HOLMES_OPS_DIR }}
          out-dir: ${{ env.HOLMES_OUT_DIR }}
          artifact-name: ${{ env.HOLMES_ARTIFACT }}
          always-generate: 'true'
          
      - name: "üß™ Install pgTAP"
        run: |
          sudo apt-get update
          sudo apt-get install -y postgresql-client
      
      - name: "üì¶ Install pgTAP into Postgres service"
        run: |
          # Install pgTAP inside the postgres:15 container as root so CREATE EXTENSION works
          set -euo pipefail
          docker exec -u 0 ${{ job.services.postgres.id }} bash -lc '
            set -euo pipefail
            export DEBIAN_FRONTEND=noninteractive
            apt-get update
            if apt-get install -y --no-install-recommends postgresql-15-pgtap; then
              echo "Installed postgresql-15-pgtap"
            elif apt-get install -y --no-install-recommends pgtap; then
              echo "Installed generic pgtap package"
            else
              echo "Failed to install pgTAP in postgres service" >&2
              exit 1
            fi
            apt-get clean && rm -rf /var/lib/apt/lists/*
          '
          
      - name: "üî® Apply Schema"
        env:
          WESLEY_OUT_DIR: out
        run: |
          # Apply the generated schema produced in the generation step
          # Ensure required extensions present (needed by generated defaults/indexes)
          PGPASSWORD=postgres psql -h localhost -U postgres -d test -c 'CREATE EXTENSION IF NOT EXISTS pgcrypto;'
          PGPASSWORD=postgres psql -h localhost -U postgres -d test -c 'CREATE EXTENSION IF NOT EXISTS "uuid-ossp";'
          PGPASSWORD=postgres psql -h localhost -U postgres -d test -c 'CREATE EXTENSION IF NOT EXISTS pg_trgm;'
          # Apply schema (fail fast on errors)
          PGPASSWORD=postgres psql -v ON_ERROR_STOP=1 -h localhost -U postgres -d test -f "example/${WESLEY_OUT_DIR}/schema.sql"

      - name: "üèóÔ∏è Ensure wes_ops schema"
        run: |
          # Ops emission targets schema wes_ops; create it if missing
          PGPASSWORD=postgres psql -h localhost -U postgres -d test -c 'CREATE SCHEMA IF NOT EXISTS wes_ops;'
      
      - name: "üì¶ Apply Ops SQL (functions only)"
        env:
          WESLEY_OUT_DIR: out
        run: |
          set -euo pipefail
          OPS_DIR="example/${WESLEY_OUT_DIR}/ops"
          shopt -s nullglob
          if [ ! -d "$OPS_DIR" ]; then
            echo "No ops SQL directory found; skipping"
            exit 0
          fi
          files=("$OPS_DIR"/*.fn.sql)
          if [ ${#files[@]} -eq 0 ]; then
            echo "No ops function SQL files found; nothing to apply"
            exit 0
          fi
          for f in "${files[@]}"; do
            if [ ! -s "$f" ]; then
              echo "Skipping empty file: $f"
              continue
            fi
            echo "Applying $f (single transaction)..."
            PGPASSWORD=postgres psql -1 -v ON_ERROR_STOP=1 -h localhost -U postgres -d test -f "$f"
          done

      - name: "üå± Seed minimal data for ops"
        run: |
          set -euo pipefail
          # Seed a couple of products (one published, one not) and run in a single transaction
          PGPASSWORD=postgres psql -v ON_ERROR_STOP=1 -h localhost -U postgres -d test <<'SQL'
          BEGIN;
          insert into product (id, sku, name, slug, price_cents, stock_quantity, published, created_at)
          values (gen_random_uuid(), 'SKU1', 'Alpha', 'alpha', 100, 10, true, now())
          on conflict do nothing;
          insert into product (id, sku, name, slug, price_cents, stock_quantity, published, created_at)
          values (gen_random_uuid(), 'SKU2', 'Beta', 'beta', 200, 0, false, now())
          on conflict do nothing;
          COMMIT;
          SQL

      - name: "üß™ Generate EXPLAIN JSON snapshots"
        env:
          WESLEY_OUT_DIR: out
        run: |
          set -euo pipefail
          mkdir -p example/${WESLEY_OUT_DIR}/ops/explain
          # EXPLAIN (FORMAT JSON) for function calls
          PGPASSWORD=postgres psql -h localhost -U postgres -d test -t -A -c "EXPLAIN (FORMAT JSON) SELECT * FROM wes_ops.op_products_by_name('Al%')" > example/${WESLEY_OUT_DIR}/ops/explain/products_by_name.explain.json
          PGPASSWORD=postgres psql -h localhost -U postgres -d test -t -A -c "EXPLAIN (FORMAT JSON) SELECT * FROM wes_ops.op_orders_by_user('00000000-0000-0000-0000-000000000000')" > example/${WESLEY_OUT_DIR}/ops/explain/orders_by_user.explain.json

      - name: "‚¨ÜÔ∏è Upload EXPLAIN snapshots"
        uses: actions/upload-artifact@v4
        with:
          name: ops-explain
          path: example/out/ops/explain/

      - name: "üß™ Run Tests"
        run: |
          set -euo pipefail
          # Optional gate: set RUN_PGTAP=false to skip pgTAP tests
          : "${RUN_PGTAP:=true}"
          # Run ops pgTAP smoke only if pgTAP is available
          HAS_PGTAP=$(PGPASSWORD=postgres psql -h localhost -U postgres -d test -t -A -c "SELECT 1 FROM pg_available_extensions WHERE name='pgtap'" || echo '')
          if [ "$RUN_PGTAP" = "true" ] && [ "$HAS_PGTAP" = "1" ]; then
            PGPASSWORD=postgres psql -v ON_ERROR_STOP=1 -h localhost -U postgres -d test -c 'CREATE EXTENSION IF NOT EXISTS pgtap;'
            PGPASSWORD=postgres psql -v ON_ERROR_STOP=1 -h localhost -U postgres -d test -f example/tests/ops.pgtap.sql
          else
            echo "pgtap extension not available; skipping pgTAP tests"
          fi
          # Simple non-pgTAP assertion: expect exactly 1 published product matching 'Al%'
          CNT=$(PGPASSWORD=postgres psql -v ON_ERROR_STOP=1 -h localhost -U postgres -d test -t -A -c "SELECT count(*) FROM wes_ops.op_products_by_name('Al%')" || echo 0)
          echo "Count from op_products_by_name('Al%') = $CNT"
          if [ "$CNT" != "1" ]; then
            echo "Expected 1 row from products_by_name, got $CNT" >&2
            exit 1
          fi
          
  comment-report:
    name: "üìù Post Investigation Report"
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    needs: [holmes-investigate, watson-verify, moriarty-predict]
    
    permissions:
      pull-requests: write
      
    steps:
      - name: "üì• Download Reports"
        uses: actions/download-artifact@v4
        with:
          merge-multiple: true
          path: reports
      
      - name: "üìù Create Comment"
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            const findReport = (artifact, filename) => {
              const base = path.join('reports', artifact);
              if (!fs.existsSync(base)) {
                console.warn(`Artifact directory missing: ${base}`);
                return `_Report missing for ${artifact}_`;
              }
              const stack = [base];
              while (stack.length) {
                const current = stack.pop();
                const entries = fs.readdirSync(current, { withFileTypes: true });
                for (const entry of entries) {
                  const fullPath = path.join(current, entry.name);
                  if (entry.isDirectory()) {
                    stack.push(fullPath);
                  } else if (entry.isFile() && entry.name === filename) {
                    return fs.readFileSync(fullPath, 'utf8');
                  }
                }
              }
              console.warn(`Expected report file ${filename} in ${base}`);
              return `_Report missing for ${artifact}_`;
            };

            const holmes = findReport('holmes-report', 'holmes-report.md');
            const watson = findReport('watson-report', 'watson-report.md');
            const moriarty = findReport('moriarty-report', 'moriarty-report.md');
            
            const body = `
            # üîç The Case of Pull Request #${{ github.event.pull_request.number }}
            
            ## üïµÔ∏è SHA-lock HOLMES's Investigation
            ${holmes}
            
            ---
            
            ## ü©∫ Dr. WATSON's Verification
            ${watson}
            
            ---
            
            ## üîÆ Professor MORIARTY's Predictions
            ${moriarty}
            
            ---
            *Filed at 221B Repository Street*
            `;
            
            // Find existing comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            
            const botComment = comments.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('The Case of Pull Request')
            );
            
            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body
              });
            }
