/**
 * Golden snapshot tests for SQL generation
 * These ensure our SQL output remains consistent
 */

import { test } from 'node:test';
import assert from 'node:assert';
import { PostgreSQLGenerator } from '../../src/domain/generators/PostgreSQLGenerator.mjs';

test('generates basic table DDL', () => {
  const generator = new PostgreSQLGenerator();
  const schema = {
    tables: {
      User: {
        name: 'User',
        uid: 'user_001',
        fields: [
          { name: 'id', type: 'ID', required: true, directives: { primaryKey: true } },
          { name: 'email', type: 'String', required: true, directives: { unique: true } },
          { name: 'name', type: 'String', required: false },
          { name: 'createdAt', type: 'DateTime', required: true }
        ]
      }
    }
  };
  
  const sql = generator.generate(schema);
  
  // Golden snapshot
  const expected = `-- Generated by Wesley
-- Schema â†’ SQL (paradigm inverted)

-- Table: User
CREATE TABLE IF NOT EXISTS "User" (
  "id" UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  "email" TEXT NOT NULL UNIQUE,
  "name" TEXT,
  "createdAt" TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Indexes
CREATE INDEX IF NOT EXISTS "idx_User_email" ON "User"("email");`;
  
  assert.strictEqual(sql.trim(), expected.trim());
});

test('generates foreign key constraints', () => {
  const generator = new PostgreSQLGenerator();
  const schema = {
    tables: {
      Order: {
        name: 'Order',
        uid: 'order_001',
        fields: [
          { name: 'id', type: 'ID', required: true, directives: { primaryKey: true } },
          { name: 'userId', type: 'ID', required: true, directives: { 
            foreignKey: { table: 'User', field: 'id', onDelete: 'CASCADE' } 
          }},
          { name: 'total', type: 'Float', required: true }
        ]
      }
    }
  };
  
  const sql = generator.generate(schema);
  
  assert(sql.includes('REFERENCES "User"("id") ON DELETE CASCADE'));
});

test('generates RLS policies with proper naming', () => {
  const generator = new PostgreSQLGenerator();
  const table = {
    name: 'Product',
    uid: 'product_001',
    rls: {
      enabled: true,
      select: 'true',
      insert: 'auth.uid() = created_by',
      update: 'auth.uid() = created_by',
      delete: 'auth.uid() = created_by'
    }
  };
  
  const policies = generator.generateRLSPolicies(table);
  
  assert(policies.includes('CREATE POLICY "policy_Product_select_product_001"'));
  assert(policies.includes('CREATE POLICY "policy_Product_insert_product_001"'));
  assert(policies.includes('CREATE POLICY "policy_Product_update_product_001"'));
  assert(policies.includes('CREATE POLICY "policy_Product_delete_product_001"'));
});

test('generates check constraints', () => {
  const generator = new PostgreSQLGenerator();
  const schema = {
    tables: {
      Product: {
        name: 'Product',
        uid: 'product_001',
        fields: [
          { name: 'id', type: 'ID', required: true, directives: { primaryKey: true } },
          { name: 'price', type: 'Float', required: true, directives: { 
            check: 'price > 0' 
          }},
          { name: 'stock', type: 'Int', required: true, directives: { 
            check: 'stock >= 0' 
          }}
        ]
      }
    }
  };
  
  const sql = generator.generate(schema);
  
  assert(sql.includes('CHECK (price > 0)'));
  assert(sql.includes('CHECK (stock >= 0)'));
});