# Wesley Security Strategy

## üéØ Production Security Approach

Wesley uses **defense in depth** with industry-standard libraries and patterns.

## üõ°Ô∏è Security Layers

### 1. **Supabase-js Integration (RECOMMENDED)**

For production deployments, Wesley schemas work with Supabase's battle-tested security:

```javascript
import { createClient } from '@supabase/supabase-js'

// ‚úÖ GOLD STANDARD: Supabase handles all security internally
const supabase = createClient(url, key)

// ‚úÖ Built-in parameterization and RLS enforcement
const { data } = await supabase
  .from('users')
  .select('*')
  .eq('id', userId)  // Automatically parameterized
```

### 2. **Parameterized Queries (CORE PATTERN)**

For direct PostgreSQL operations:

```javascript
// ‚úÖ SECURE: Parameters are escaped automatically
const result = await client.query(
  'SELECT * FROM users WHERE email = $1 AND org_id = $2',
  [email, orgId]
);

// ‚ùå VULNERABLE: String interpolation
const result = await client.query(
  `SELECT * FROM users WHERE email = '${email}'`  // SQL INJECTION RISK
);
```

### 3. **Schema Generation Security (Wesley-specific)**

Since DDL can't be parameterized, Wesley validates + escapes:

```javascript
// ‚úÖ VALIDATED: Wesley checks identifiers before generation
validateSQLIdentifier(tableName, 'table name');
const sql = `CREATE TABLE ${escapeIdentifier(tableName)} (...)`;

// ‚úÖ TEMPLATE APPROACH: Even safer
const sql = buildDDL(DDL_TEMPLATES.CREATE_TABLE, {
  table: tableName  // Validated and quoted automatically
});
```

### 4. **RLS Policy Security**

Wesley generates RLS policies that integrate with Supabase auth:

```sql
-- ‚úÖ WESLEY-GENERATED: Safe RLS patterns
CREATE POLICY "users_own_data" ON users
  FOR ALL TO authenticated
  USING (auth.uid() = user_id);

-- ‚ùå DANGEROUS: Never generated by Wesley  
CREATE POLICY "bypass_all" ON users
  FOR ALL TO authenticated  
  USING (true);  -- Bypasses all security
```

Note on clause semantics:

- INSERT policies use WITH CHECK to validate new rows: e.g., `CREATE POLICY ... FOR INSERT ... WITH CHECK (auth.uid() = user_id)`.
- UPDATE policies commonly include both USING (which rows are visible to update) and WITH CHECK (what the new row must satisfy): e.g., `CREATE POLICY ... FOR UPDATE ... USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id)`.


## üß™ Security Testing

Wesley includes comprehensive security test suites:

- **SQL injection prevention** - 20+ attack vectors tested
- **Parameter validation** - Edge cases and dangerous patterns
- **RLS policy validation** - Prevents bypass attempts  
- **Input sanitization** - Standard PostgreSQL escaping

## üìã Security Checklist

### For Wesley Schema Authors
- ‚úÖ Use Wesley directives (@table, @rls, @check) - they're validated
- ‚úÖ Define RLS policies in GraphQL - Wesley ensures they're safe
- ‚ùå Never include raw SQL in schema comments or descriptions


### For Wesley Runtime Users
- ‚úÖ **PREFER**: Supabase-js client for all data operations
- ‚úÖ **FALLBACK**: Parameterized queries with pg library
- ‚ùå **NEVER**: String interpolation or template literals with user data


### For Production Deployment
- ‚úÖ All Wesley-generated SQL is pre-validated for security
- ‚úÖ RLS policies are auto-enabled on all @rls tables
- ‚úÖ Check constraints are validated for dangerous patterns
- ‚úÖ Advisory locks prevent concurrent migration conflicts

## üîó Related Security Resources

- [Supabase Auth Documentation](https://supabase.com/docs/guides/auth)
- [PostgreSQL Security Best Practices](https://www.postgresql.org/docs/current/security.html)
- [OWASP SQL Injection Prevention](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)

## üö® Security Contact

Found a security issue? Please report it privately to the maintainers rather than opening a public issue.

---

**Wesley's Philosophy**: *Be the "adult in the room" for database security - no surprises, no vulnerabilities, just boring reliability.*
