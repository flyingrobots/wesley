# Wesley Security Strategy

## üéØ Production Security Approach

Wesley uses **defense in depth** with industry-standard libraries and patterns.

## üõ°Ô∏è Security Layers

### 1. **Supabase-js Integration (RECOMMENDED)**

For production deployments, Wesley schemas work with Supabase's battle-tested security:

```javascript
import { createClient } from '@supabase/supabase-js'

// ‚úÖ GOLD STANDARD: Supabase handles all security internally
const supabase = createClient(url, key)

// ‚úÖ Built-in parameterization and RLS enforcement
const { data } = await supabase
  .from('users')
  .select('*')
  .eq('id', userId)  // Automatically parameterized
```

### 2. **Parameterized Queries (CORE PATTERN)**

For direct PostgreSQL operations:

```javascript
// ‚úÖ SECURE: Parameters are escaped automatically
const result = await client.query(
  'SELECT * FROM users WHERE email = $1 AND org_id = $2',
  [email, orgId]
);

// ‚ùå VULNERABLE: String interpolation
const result = await client.query(
  `SELECT * FROM users WHERE email = '${email}'`  // SQL INJECTION RISK
);
```

### 3. **Schema Generation Security (Wesley-specific)**

Since DDL can't be parameterized, Wesley validates + escapes:

```javascript
import { buildDDL, DDL_TEMPLATES, formatColumnDefs } from '@wesley/core/domain/security/StandardSanitizer.mjs';

// ‚úÖ TEMPLATE APPROACH (recommended)
const tableSQL = buildDDL(DDL_TEMPLATES.CREATE_TABLE, {
  table: 'users',
  column_defs: formatColumnDefs([
    '"id" uuid PRIMARY KEY',
    '"email" text NOT NULL'
  ])
});

// ‚úÖ RLS policy templates
const insertPolicy = buildDDL(DDL_TEMPLATES.CREATE_POLICY_WITH_CHECK, {
  policy: 'p_users_insert_owner',
  table: 'users',
  operation: 'INSERT',
  roles: ['authenticated'],
  check: 'auth.uid() = owner_id'
});

const updatePolicy = buildDDL(DDL_TEMPLATES.CREATE_POLICY_USING_WITH_CHECK, {
  policy: 'p_users_update_owner',
  table: 'users',
  operation: 'UPDATE',
  roles: ['PUBLIC'],            // special roles are unquoted and case-insensitive
  using: 'auth.uid() = owner_id',
  check: 'auth.uid() = owner_id'
});
```

### 4. **RLS Policy Security**

Wesley generates RLS policies that integrate with Supabase auth:

```sql
-- ‚úÖ WESLEY-GENERATED: Safe RLS patterns
CREATE POLICY "users_own_data" ON users
  FOR ALL TO authenticated
  USING (auth.uid() = user_id);

-- ‚ùå DANGEROUS: Never generated by Wesley  
CREATE POLICY "bypass_all" ON users
  FOR ALL TO authenticated  
  USING (true);  -- Bypasses all security
```

Choosing the right policy clause:

- SELECT/DELETE ‚Üí USING only
- INSERT ‚Üí WITH CHECK only
- UPDATE ‚Üí USING and WITH CHECK

These templates match RLSPresets output (owner/tenant/public-read, etc.).

### 5. **Evidence and Source Mapping**

- EvidenceMap is the source of truth for where schema elements land in generated artifacts. Generators record evidence using stable UIDs:
  - Tables: `tbl:TableName`
  - Columns: `col:TableName.columnName`
- SQL `COMMENT ON ... 'uid: ‚Ä¶'` strings are informational hints only. Consumers (SourceMap, scoring, HOLMES) read from EvidenceMap.
- To map a SQL error back to SDL, use SourceMap utilities (e.g., `findSourceForSql(evidenceMap, { file, line })`).

Example (Node):

```js
import fs from 'node:fs/promises';
import { EvidenceMap } from '@wesley/core';
// Temporary deep import until re-exported at package root
import { findSourceForSql } from '@wesley/core/src/application/SourceMap.mjs';

// Load bundle produced by: wesley generate --emit-bundle
const raw = await fs.readFile('.wesley/bundle.json', 'utf8');
const bundle = JSON.parse(raw);

// Accept either flat { evidence: {...} } or nested { evidence: { evidence: {...} } }
const payload = bundle?.evidence?.evidence ? bundle.evidence : bundle;
const ev = EvidenceMap.fromJSON(payload);

// Suppose a failure references out/schema.sql:123
const result = findSourceForSql(ev, { file: 'out/schema.sql', line: 123 });
// result: { uid: 'col:Table.field', source: { file: 'schema.graphql', lines: 'X-Y', columns: 'A-B' } }
```



## üß™ Security Testing

Wesley includes comprehensive security test suites:

- **SQL injection prevention** - 20+ attack vectors tested
- **Parameter validation** - Edge cases and dangerous patterns
- **RLS policy validation** - Prevents bypass attempts  
- **Input sanitization** - Standard PostgreSQL escaping

## üìã Security Checklist

### For Wesley Schema Authors
- ‚úÖ Use Wesley directives (@table, @rls, @check) - they're validated
- ‚úÖ Define RLS policies in GraphQL - Wesley ensures they're safe
- ‚ùå Never include raw SQL in schema comments or descriptions


### For Wesley Runtime Users
- ‚úÖ **PREFER**: Supabase-js client for all data operations
- ‚úÖ **FALLBACK**: Parameterized queries with pg library
- ‚ùå **NEVER**: String interpolation or template literals with user data


### For Production Deployment
- ‚úÖ All Wesley-generated SQL is pre-validated for security
- ‚úÖ RLS policies are auto-enabled on all @rls tables
- ‚úÖ Check constraints are validated for dangerous patterns
- ‚úÖ Advisory locks prevent concurrent migration conflicts

## üîó Related Security Resources

- [Supabase Auth Documentation](https://supabase.com/docs/guides/auth)
- [PostgreSQL Security Best Practices](https://www.postgresql.org/docs/current/security.html)
- [OWASP SQL Injection Prevention](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)

## üö® Security Contact

Found a security issue? Please report it privately to the maintainers rather than opening a public issue.

---

**Wesley's Philosophy**: *Be the "adult in the room" for database security - no surprises, no vulnerabilities, just boring reliability.*
