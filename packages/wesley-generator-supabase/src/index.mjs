/**
 * Supabase Generator
 * Generates typed Supabase client wrapper with RLS helpers and CRUD operations
 */

export class SupabaseGenerator {
  constructor(evidenceMap) {
    this.evidenceMap = evidenceMap;
  }
  
  /**
   * Generate typed Supabase client from Wesley schema
   */
  generate(schema) {
    const sections = [];
    
    // Generate imports
    sections.push(this.generateImports());
    sections.push('');
    
    // Generate database types interface
    sections.push(this.generateDatabaseTypes(schema));
    sections.push('');
    
    // Generate main client class
    sections.push(this.generateClientClass(schema));
    sections.push('');
    
    // Generate table-specific classes
    for (const table of schema.getTables()) {
      sections.push(this.generateTableClass(table, schema));
      sections.push('');
      
      // Record evidence
      if (this.evidenceMap) {
        const tableUid = table.directives?.['@uid'] || `table_${table.name.toLowerCase()}`;
        this.evidenceMap.record(tableUid, 'supabase', {
          file: 'generated/supabase.ts',
          lines: `${sections.length - 1}-${sections.length - 1}`
        });
      }
    }
    
    // Generate utility functions
    sections.push(this.generateUtilities());
    
    return sections.join('\n');
  }
  
  /**
   * Generate import statements
   */
  generateImports() {
    return `import { createClient, SupabaseClient, PostgrestFilterBuilder } from '@supabase/supabase-js';
import type { Database } from './database-types';

// Re-export commonly used types
export type { Database } from './database-types';
export type Tables = Database['public']['Tables'];
export type TableRow<T extends keyof Tables> = Tables[T]['Row'];
export type TableInsert<T extends keyof Tables> = Tables[T]['Insert'];
export type TableUpdate<T extends keyof Tables> = Tables[T]['Update'];`;
  }
  
  /**
   * Generate database types interface (Supabase format)
   */
  generateDatabaseTypes(schema) {
    const tables = {};
    
    for (const table of schema.getTables()) {
      const row = {};
      const insert = {};
      const update = {};
      
      for (const field of table.getFields()) {
        if (field.isVirtual()) continue;
        
        const tsType = this.getTypeScriptType(field);
        
        // Row type (what comes from database)
        row[field.name] = tsType;
        
        // Insert type (what can be inserted)
        if (!this.isAutoGenerated(field)) {
          insert[field.name] = field.nonNull ? tsType : `${tsType} | null`;
        }
        
        // Update type (what can be updated)
        if (!this.isImmutable(field)) {
          update[field.name] = `${tsType} | null`;
        }
      }
      
      tables[table.name] = {
        Row: this.formatTypeObject(row),
        Insert: this.formatTypeObject(insert), 
        Update: this.formatTypeObject(update)
      };
    }
    
    return `export interface Database {
  public: {
    Tables: {
${Object.entries(tables).map(([name, types]) => 
      `      ${name}: {
        Row: ${types.Row}
        Insert: ${types.Insert}
        Update: ${types.Update}
      }`
    ).join('\n')}
    }
    Views: {
      [_ in never]: never
    }
    Functions: {
      [_ in never]: never
    }
    Enums: {
      [_ in never]: never
    }
    CompositeTypes: {
      [_ in never]: never
    }
  }
}`;
  }
  
  /**
   * Format TypeScript object type
   */
  formatTypeObject(obj) {
    const entries = Object.entries(obj);
    if (entries.length === 0) {
      return '{}';
    }
    
    const fields = entries.map(([key, value]) => `        ${key}: ${value}`);
    return `{\n${fields.join('\n')}\n      }`;
  }
  
  /**
   * Generate main client class
   */
  generateClientClass(schema) {
    const tableProperties = schema.getTables()
      .map(table => `  readonly ${table.name.toLowerCase()}: ${table.name}Repository;`)
      .join('\n');
    
    const tableInitializers = schema.getTables()
      .map(table => `    this.${table.name.toLowerCase()} = new ${table.name}Repository(this.client);`)
      .join('\n');
    
    return `/**
 * Typed Supabase client with repository pattern
 */
export class TypedSupabaseClient {
  private client: SupabaseClient<Database>;
  
${tableProperties}
  
  constructor(url: string, anonKey: string, options?: any) {
    this.client = createClient<Database>(url, anonKey, options);
    
    // Initialize table repositories
${tableInitializers}
  }
  
  /**
   * Get raw Supabase client
   */
  get raw() {
    return this.client;
  }
  
  /**
   * Authentication helpers
   */
  get auth() {
    return this.client.auth;
  }
  
  /**
   * Storage helpers
   */
  get storage() {
    return this.client.storage;
  }
  
  /**
   * RPC function calls
   */
  rpc<T = any>(fn: string, args?: object): Promise<{ data: T | null; error: any }> {
    return this.client.rpc(fn, args);
  }
  
  /**
   * Real-time subscriptions
   */
  channel(name: string) {
    return this.client.channel(name);
  }
}`;
  }
  
  /**
   * Generate table-specific repository class
   */
  generateTableClass(table, schema) {
    const className = `${table.name}Repository`;
    const tableName = table.name.toLowerCase();
    
    // Generate RLS helper methods
    const rlsMethods = this.generateRLSMethods(table);
    
    // Generate relationship methods
    const relationMethods = this.generateRelationshipMethods(table, schema);
    
    return `/**
 * Repository for ${table.name} table
 */
export class ${className} {
  constructor(private client: SupabaseClient<Database>) {}
  
  /**
   * Get base query builder
   */
  private get query() {
    return this.client.from('${tableName}');
  }
  
  /**
   * Select all records
   */
  async findAll(): Promise<{ data: TableRow<'${table.name}'>[] | null; error: any }> {
    return this.query.select('*');
  }
  
  /**
   * Select records with custom select
   */
  select(columns = '*') {
    return this.query.select(columns);
  }
  
  /**
   * Find by primary key
   */
  async findById(id: string): Promise<{ data: TableRow<'${table.name}'> | null; error: any }> {
    return this.query
      .select('*')
      .eq('${this.getPrimaryKeyField(table)}', id)
      .single();
  }
  
  /**
   * Create new record
   */
  async create(data: TableInsert<'${table.name}'>): Promise<{ data: TableRow<'${table.name}'> | null; error: any }> {
    return this.query
      .insert(data)
      .select()
      .single();
  }
  
  /**
   * Create multiple records
   */
  async createMany(data: TableInsert<'${table.name}'>[]): Promise<{ data: TableRow<'${table.name}'>[] | null; error: any }> {
    return this.query
      .insert(data)
      .select();
  }
  
  /**
   * Update record by ID
   */
  async updateById(id: string, data: TableUpdate<'${table.name}'>): Promise<{ data: TableRow<'${table.name}'> | null; error: any }> {
    return this.query
      .update(data)
      .eq('${this.getPrimaryKeyField(table)}', id)
      .select()
      .single();
  }
  
  /**
   * Update records with conditions
   */
  update(data: TableUpdate<'${table.name}'>) {
    return this.query.update(data);
  }
  
  /**
   * Delete record by ID
   */
  async deleteById(id: string): Promise<{ data: null; error: any }> {
    return this.query
      .delete()
      .eq('${this.getPrimaryKeyField(table)}', id);
  }
  
  /**
   * Delete records with conditions
   */
  delete() {
    return this.query.delete();
  }
  
  /**
   * Count records
   */
  async count(options?: { exact?: boolean }): Promise<{ count: number | null; error: any }> {
    return this.query
      .select('*', { count: options?.exact ? 'exact' : 'estimated', head: true });
  }
  
  /**
   * Upsert (insert or update)
   */
  async upsert(data: TableInsert<'${table.name}'> | TableInsert<'${table.name}'>[]): Promise<{ data: TableRow<'${table.name}'>[] | null; error: any }> {
    return this.query
      .upsert(data)
      .select();
  }
${rlsMethods}${relationMethods}
}`;
  }
  
  /**
   * Generate RLS helper methods for a table
   */
  generateRLSMethods(table) {
    const methods = [];
    
    // Check if table has RLS enabled
    if (table.directives?.['@rls']) {
      const rlsConfig = table.directives['@rls'];
      
      methods.push(`
  /**
   * RLS Helper: Filter by current user
   */
  forCurrentUser() {
    return this.query.eq('user_id', this.client.auth.getUser()?.data.user?.id);
  }`);
      
      // Add tenant-based filtering if configured
      if (table.directives?.['@tenant']) {
        methods.push(`
  /**
   * RLS Helper: Filter by tenant
   */
  forTenant(tenantId: string) {
    return this.query.eq('tenant_id', tenantId);
  }`);
      }
      
      // Add organization-based filtering
      if (this.hasField(table, 'org_id')) {
        methods.push(`
  /**
   * RLS Helper: Filter by organization
   */
  forOrganization(orgId: string) {
    return this.query.eq('org_id', orgId);
  }`);
      }
    }
    
    return methods.join('');
  }
  
  /**
   * Generate relationship helper methods
   */
  generateRelationshipMethods(table, schema) {
    const methods = [];
    
    for (const field of table.getFields()) {
      if (field.directives?.['@hasMany']) {
        const hasMany = field.directives['@hasMany'];
        const relatedTable = hasMany.target || field.type;
        const foreignKey = hasMany.foreignKey || `${table.name.toLowerCase()}_id`;
        
        methods.push(`
  /**
   * Get related ${field.name} (hasMany relationship)
   */
  async get${this.capitalize(field.name)}(id: string) {
    return this.client
      .from('${relatedTable.toLowerCase()}')
      .select('*')
      .eq('${foreignKey}', id);
  }`);
      }
      
      if (field.directives?.['@hasOne']) {
        const hasOne = field.directives['@hasOne'];
        const relatedTable = hasOne.target || field.type;
        const foreignKey = hasOne.foreignKey || `${table.name.toLowerCase()}_id`;
        
        methods.push(`
  /**
   * Get related ${field.name} (hasOne relationship)
   */
  async get${this.capitalize(field.name)}(id: string) {
    return this.client
      .from('${relatedTable.toLowerCase()}')
      .select('*')
      .eq('${foreignKey}', id)
      .single();
  }`);
      }
    }
    
    return methods.join('');
  }
  
  /**
   * Generate utility functions
   */
  generateUtilities() {
    return `/**
 * Create typed Supabase client instance
 */
export function createTypedSupabaseClient(url: string, anonKey: string, options?: any) {
  return new TypedSupabaseClient(url, anonKey, options);
}

/**
 * Type-safe query builder helpers
 */
export type QueryBuilder<T extends keyof Tables> = PostgrestFilterBuilder<
  Database,
  Database['public']['Tables'][T]['Row'],
  any
>;

/**
 * Type-safe subscription helpers
 */
export interface RealtimeSubscription<T extends keyof Tables> {
  on: (
    event: 'INSERT' | 'UPDATE' | 'DELETE' | '*',
    callback: (payload: {
      eventType: 'INSERT' | 'UPDATE' | 'DELETE';
      new: TableRow<T>;
      old: TableRow<T>;
      errors: any[];
    }) => void
  ) => RealtimeSubscription<T>;
  subscribe: () => void;
}

/**
 * Batch operation helpers
 */
export class BatchOperations {
  private operations: Array<() => Promise<any>> = [];
  
  add<T extends keyof Tables>(operation: () => Promise<any>) {
    this.operations.push(operation);
    return this;
  }
  
  async execute() {
    return Promise.all(this.operations.map(op => op()));
  }
  
  async executeSequential() {
    const results = [];
    for (const operation of this.operations) {
      results.push(await operation());
    }
    return results;
  }
}`;
  }
  
  /**
   * Get TypeScript type for a field
   */
  getTypeScriptType(field) {
    if (field.list) {
      const baseType = this.getScalarType(field.type);
      return field.itemNonNull ? `${baseType}[]` : `(${baseType} | null)[]`;
    }
    
    const baseType = this.getScalarType(field.type);
    return field.nonNull ? baseType : `${baseType} | null`;
  }
  
  /**
   * Get scalar TypeScript type
   */
  getScalarType(type) {
    const typeMap = {
      'ID': 'string',
      'String': 'string',
      'Int': 'number',
      'Float': 'number',
      'Boolean': 'boolean',
      'DateTime': 'string',
      'Date': 'string',
      'Time': 'string',
      'Decimal': 'number',
      'UUID': 'string',
      'JSON': 'Record<string, any>',
      'Inet': 'string',
      'CIDR': 'string',
      'MacAddr': 'string'
    };
    
    return typeMap[type] || 'unknown';
  }
  
  /**
   * Check if field is auto-generated
   */
  isAutoGenerated(field) {
    return (field.isPrimaryKey() && field.directives?.['@default']) ||
           field.name === 'createdAt' ||
           field.name === 'updatedAt';
  }
  
  /**
   * Check if field is immutable
   */
  isImmutable(field) {
    return field.isPrimaryKey() || field.name === 'createdAt';
  }
  
  /**
   * Get primary key field name
   */
  getPrimaryKeyField(table) {
    for (const field of table.getFields()) {
      if (field.isPrimaryKey()) {
        return field.name;
      }
    }
    return 'id'; // Default assumption
  }
  
  /**
   * Check if table has a specific field
   */
  hasField(table, fieldName) {
    return table.getFields().some(field => field.name === fieldName);
  }
  
  /**
   * Capitalize first letter
   */
  capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
}