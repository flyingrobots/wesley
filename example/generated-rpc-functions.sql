-- RPC Functions generated by Wesley from GraphQL Mutations
-- Optimized for Supabase PostgREST API
-- Generated: 2024-03-20T10:30:00Z

-- ══════════════════════════════════════════════════════════════════
-- USER REGISTRATION WITH CART CREATION
-- From: registerUser mutation
-- ══════════════════════════════════════════════════════════════════

CREATE OR REPLACE FUNCTION register_user(
  email text,
  password text,
  full_name text
)
RETURNS json
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, auth
AS $$
DECLARE
  new_user_id uuid;
  new_user record;
BEGIN
  -- Create auth user (integrates with Supabase Auth)
  new_user_id := auth.create_user(
    email := email,
    password := password,
    email_confirm := false
  );
  
  -- Create profile record
  INSERT INTO "User" (id, email, full_name, created_at)
  VALUES (new_user_id, email, full_name, now())
  RETURNING * INTO new_user;
  
  -- Create empty cart
  INSERT INTO "Cart" (user_id, expires_at)
  VALUES (new_user_id, now() + interval '7 days');
  
  -- Return user data for PostgREST
  RETURN json_build_object(
    'id', new_user.id,
    'email', new_user.email,
    'full_name', new_user.full_name,
    'created_at', new_user.created_at
  );
EXCEPTION
  WHEN unique_violation THEN
    RAISE EXCEPTION 'User with email % already exists', email
      USING ERRCODE = 'CONFL';
  WHEN OTHERS THEN
    RAISE EXCEPTION 'Registration failed: %', SQLERRM
      USING ERRCODE = 'INTER';
END;
$$;

-- Grant execute to anon for registration
GRANT EXECUTE ON FUNCTION register_user TO anon;
COMMENT ON FUNCTION register_user IS 'Public registration endpoint';

-- ══════════════════════════════════════════════════════════════════
-- ADD TO CART WITH STOCK VALIDATION
-- From: addToCart mutation
-- ══════════════════════════════════════════════════════════════════

CREATE OR REPLACE FUNCTION add_to_cart(
  product_id uuid,
  quantity integer
)
RETURNS json
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  cart_id uuid;
  product record;
  cart_item record;
  current_quantity integer;
BEGIN
  -- Verify authenticated
  IF auth.uid() IS NULL THEN
    RAISE EXCEPTION 'Authentication required'
      USING ERRCODE = 'AUTHN';
  END IF;
  
  -- Get user's cart
  SELECT id INTO cart_id
  FROM "Cart"
  WHERE user_id = auth.uid()
    AND expires_at > now();
  
  IF cart_id IS NULL THEN
    -- Create new cart if expired
    INSERT INTO "Cart" (user_id, expires_at)
    VALUES (auth.uid(), now() + interval '7 days')
    RETURNING id INTO cart_id;
  END IF;
  
  -- Get product and check stock
  SELECT * INTO product
  FROM "Product"
  WHERE id = product_id
    AND published = true
  FOR UPDATE; -- Lock for stock check
  
  IF product IS NULL THEN
    RAISE EXCEPTION 'Product not found or unavailable'
      USING ERRCODE = 'NTFND';
  END IF;
  
  -- Get current quantity in cart
  SELECT COALESCE(ci.quantity, 0) INTO current_quantity
  FROM "CartItem" ci
  WHERE ci.cart_id = cart_id
    AND ci.product_id = product_id;
  
  -- Check stock availability
  IF product.stock_quantity < (current_quantity + quantity) THEN
    RAISE EXCEPTION 'Insufficient stock. Available: %, Requested: %',
      product.stock_quantity - current_quantity, quantity
      USING ERRCODE = 'STOCK';
  END IF;
  
  -- Add or update cart item
  INSERT INTO "CartItem" (cart_id, product_id, quantity)
  VALUES (cart_id, product_id, quantity)
  ON CONFLICT (cart_id, product_id) DO UPDATE
  SET quantity = "CartItem".quantity + EXCLUDED.quantity
  RETURNING * INTO cart_item;
  
  -- Return cart item with product details for PostgREST
  RETURN json_build_object(
    'id', cart_item.id,
    'quantity', cart_item.quantity,
    'product', json_build_object(
      'id', product.id,
      'name', product.name,
      'price_cents', product.price_cents,
      'stock_quantity', product.stock_quantity - cart_item.quantity
    )
  );
END;
$$;

-- Grant execute to authenticated users
GRANT EXECUTE ON FUNCTION add_to_cart TO authenticated;
COMMENT ON FUNCTION add_to_cart IS 'Add product to user cart with stock validation';

-- ══════════════════════════════════════════════════════════════════
-- CHECKOUT WITH TRANSACTION AND INVENTORY
-- From: checkout mutation
-- ══════════════════════════════════════════════════════════════════

CREATE OR REPLACE FUNCTION checkout(
  shipping_address jsonb,
  billing_address jsonb,
  payment_method_id text DEFAULT NULL
)
RETURNS json
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  cart_id uuid;
  new_order record;
  subtotal integer := 0;
  tax_amount integer;
  shipping_amount integer := 500; -- $5 flat shipping
  total_amount integer;
  order_number text;
  item record;
BEGIN
  -- Verify authenticated
  IF auth.uid() IS NULL THEN
    RAISE EXCEPTION 'Authentication required'
      USING ERRCODE = 'AUTHN';
  END IF;
  
  -- Get user's cart
  SELECT id INTO cart_id
  FROM "Cart"
  WHERE user_id = auth.uid()
    AND expires_at > now();
  
  IF cart_id IS NULL THEN
    RAISE EXCEPTION 'No active cart found'
      USING ERRCODE = 'NTFND';
  END IF;
  
  -- Check cart has items
  IF NOT EXISTS (SELECT 1 FROM "CartItem" WHERE cart_id = cart_id) THEN
    RAISE EXCEPTION 'Cart is empty'
      USING ERRCODE = 'EMPTY';
  END IF;
  
  -- Calculate subtotal and validate stock (with row locks)
  FOR item IN
    SELECT ci.*, p.price_cents, p.stock_quantity, p.name, p.sku
    FROM "CartItem" ci
    JOIN "Product" p ON ci.product_id = p.id
    WHERE ci.cart_id = cart_id
    FOR UPDATE OF p
  LOOP
    -- Validate stock
    IF item.stock_quantity < item.quantity THEN
      RAISE EXCEPTION 'Insufficient stock for product: %', item.name
        USING ERRCODE = 'STOCK';
    END IF;
    
    subtotal := subtotal + (item.price_cents * item.quantity);
  END LOOP;
  
  -- Calculate totals
  tax_amount := subtotal * 0.1; -- 10% tax
  total_amount := subtotal + tax_amount + shipping_amount;
  
  -- Generate order number
  order_number := 'ORD-' || to_char(now(), 'YYYYMMDD') || '-' || 
                  lpad(nextval('order_number_seq')::text, 6, '0');
  
  -- Create order
  INSERT INTO "Order" (
    user_id, order_number, status,
    subtotal_cents, tax_cents, shipping_cents, total_cents,
    shipping_address, billing_address,
    payment_status, created_at
  )
  VALUES (
    auth.uid(), order_number, 'pending',
    subtotal, tax_amount, shipping_amount, total_amount,
    shipping_address, billing_address,
    'pending', now()
  )
  RETURNING * INTO new_order;
  
  -- Copy cart items to order items and update inventory
  FOR item IN
    SELECT ci.*, p.price_cents, p.name, p.sku, p.id as product_id
    FROM "CartItem" ci
    JOIN "Product" p ON ci.product_id = p.id
    WHERE ci.cart_id = cart_id
  LOOP
    -- Create order item
    INSERT INTO "OrderItem" (
      order_id, product_id, quantity, 
      unit_price_cents, subtotal_cents,
      product_name, product_sku
    )
    VALUES (
      new_order.id, item.product_id, item.quantity,
      item.price_cents, item.price_cents * item.quantity,
      item.name, item.sku
    );
    
    -- Update product stock
    UPDATE "Product"
    SET stock_quantity = stock_quantity - item.quantity
    WHERE id = item.product_id;
    
    -- Create inventory log
    INSERT INTO "InventoryLog" (
      product_id, quantity_change, quantity_after,
      reason, reference_id, created_by
    )
    VALUES (
      item.product_id, 
      -item.quantity,
      (SELECT stock_quantity FROM "Product" WHERE id = item.product_id),
      'sale', 
      new_order.id, 
      auth.uid()
    );
  END LOOP;
  
  -- Clear cart
  DELETE FROM "CartItem" WHERE cart_id = cart_id;
  UPDATE "Cart" SET expires_at = now() WHERE id = cart_id;
  
  -- Return order for PostgREST
  RETURN json_build_object(
    'id', new_order.id,
    'order_number', new_order.order_number,
    'status', new_order.status,
    'total_cents', new_order.total_cents,
    'created_at', new_order.created_at,
    'payment_url', '/checkout/pay/' || new_order.id
  );
EXCEPTION
  WHEN OTHERS THEN
    -- Rollback is automatic in PL/pgSQL
    RAISE EXCEPTION 'Checkout failed: %', SQLERRM;
END;
$$;

-- Grant execute to authenticated users
GRANT EXECUTE ON FUNCTION checkout TO authenticated;
COMMENT ON FUNCTION checkout IS 'Complete checkout process with inventory management';

-- ══════════════════════════════════════════════════════════════════
-- CANCEL ORDER WITH STOCK RESTORATION
-- From: cancelOrder mutation
-- ══════════════════════════════════════════════════════════════════

CREATE OR REPLACE FUNCTION cancel_order(order_id uuid)
RETURNS json
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  order_record record;
  item record;
BEGIN
  -- Get order and verify ownership
  SELECT * INTO order_record
  FROM "Order"
  WHERE id = order_id
    AND user_id = auth.uid()
  FOR UPDATE;
  
  IF order_record IS NULL THEN
    RAISE EXCEPTION 'Order not found'
      USING ERRCODE = 'NTFND';
  END IF;
  
  IF order_record.status != 'pending' THEN
    RAISE EXCEPTION 'Only pending orders can be cancelled'
      USING ERRCODE = 'STATE';
  END IF;
  
  -- Restore inventory for each item
  FOR item IN
    SELECT * FROM "OrderItem"
    WHERE order_id = order_id
  LOOP
    -- Restore stock
    UPDATE "Product"
    SET stock_quantity = stock_quantity + item.quantity
    WHERE id = item.product_id;
    
    -- Log inventory change
    INSERT INTO "InventoryLog" (
      product_id, quantity_change, quantity_after,
      reason, reference_id, created_by
    )
    VALUES (
      item.product_id, 
      item.quantity,
      (SELECT stock_quantity FROM "Product" WHERE id = item.product_id),
      'return', 
      order_id, 
      auth.uid()
    );
  END LOOP;
  
  -- Update order status
  UPDATE "Order"
  SET status = 'cancelled',
      cancelled_at = now()
  WHERE id = order_id;
  
  -- Return updated order
  RETURN json_build_object(
    'id', order_id,
    'status', 'cancelled',
    'cancelled_at', now()
  );
END;
$$;

-- Grant execute to authenticated users
GRANT EXECUTE ON FUNCTION cancel_order TO authenticated;
COMMENT ON FUNCTION cancel_order IS 'Cancel pending order and restore inventory';

-- ══════════════════════════════════════════════════════════════════
-- ADMIN: RESTOCK PRODUCT
-- From: restockProduct mutation
-- ══════════════════════════════════════════════════════════════════

CREATE OR REPLACE FUNCTION restock_product(
  product_id uuid,
  quantity integer,
  batch_id uuid DEFAULT NULL
)
RETURNS json
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  user_role text;
  product record;
BEGIN
  -- Check admin role
  SELECT role INTO user_role
  FROM "User"
  WHERE id = auth.uid();
  
  IF user_role NOT IN ('admin', 'warehouse') THEN
    RAISE EXCEPTION 'Unauthorized: admin or warehouse role required'
      USING ERRCODE = 'AUTHZ';
  END IF;
  
  -- Update stock
  UPDATE "Product"
  SET stock_quantity = stock_quantity + quantity,
      updated_at = now()
  WHERE id = product_id
  RETURNING * INTO product;
  
  IF product IS NULL THEN
    RAISE EXCEPTION 'Product not found'
      USING ERRCODE = 'NTFND';
  END IF;
  
  -- Log inventory change
  INSERT INTO "InventoryLog" (
    product_id, quantity_change, quantity_after,
    reason, reference_id, created_by
  )
  VALUES (
    product_id, quantity, product.stock_quantity,
    'restock', batch_id, auth.uid()
  );
  
  -- Return updated product
  RETURN json_build_object(
    'id', product.id,
    'name', product.name,
    'stock_quantity', product.stock_quantity,
    'updated_at', product.updated_at
  );
END;
$$;

-- Grant execute to authenticated (RLS will check role)
GRANT EXECUTE ON FUNCTION restock_product TO authenticated;
COMMENT ON FUNCTION restock_product IS 'Admin function to restock product inventory';

-- ══════════════════════════════════════════════════════════════════
-- HELPER FUNCTIONS
-- ══════════════════════════════════════════════════════════════════

-- Create sequence for order numbers if not exists
CREATE SEQUENCE IF NOT EXISTS order_number_seq;

-- Function to clean expired carts (run via pg_cron)
CREATE OR REPLACE FUNCTION clean_expired_carts()
RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN
  -- Delete items from expired carts
  DELETE FROM "CartItem"
  WHERE cart_id IN (
    SELECT id FROM "Cart"
    WHERE expires_at < now() - interval '1 day'
  );
  
  -- Delete expired carts
  DELETE FROM "Cart"
  WHERE expires_at < now() - interval '1 day';
END;
$$;

-- Schedule with pg_cron (if available)
-- SELECT cron.schedule('clean-carts', '0 2 * * *', 'SELECT clean_expired_carts();');