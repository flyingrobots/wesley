Perfect—here’s the Wesley GraphQL INPUT I’d write for S.E.O. You paste this into schema.graphql; Wesley compiles it into Postgres (tables, views, policies), RPCs, realtime, tests, the works. Your original spirit stays intact; I’m just making it compiler-friendly and unambiguous.

Strong take: Queries come from @view types exposed on type Query. Mutations are @rpc-backed fields on type Mutation. Everything else is tables + relationships.

""" ---------------------------------------------
 S.E.O. - Synergistic Enhancement Orchestrator
 GraphQL INPUT for Wesley → Postgres/Supabase
----------------------------------------------"""

# ======================
# Core scalar mappings
# ======================
scalar DateTime      # timestamptz
scalar UUID          # uuid
scalar JSON          # jsonb
scalar Percentage    # numeric(5,2) 0..100 with CHECK
scalar BandwidthScore# numeric(6,3) 0..100 with CHECK
scalar Cursor        # opaque pagination cursor

# ======================
# Wesley directive API
# ======================
enum OnDeleteRule { RESTRICT CASCADE SET_NULL SET_DEFAULT }

directive @table on OBJECT
directive @view on OBJECT
directive @rpc on FIELD_DEFINITION | OBJECT
directive @rls(enable: Boolean!) on OBJECT
directive @realtime on OBJECT
directive @audit on OBJECT
directive @partitioned(by: String!) on OBJECT
directive @ephemeral(ttl: String!) on OBJECT
directive @tenant(by: String) on OBJECT

# Field-level
directive @pk on FIELD_DEFINITION
directive @unique on FIELD_DEFINITION
directive @uniqueComposite(fields: [String!]!) on OBJECT
directive @fk(ref: String!, onDelete: OnDeleteRule = RESTRICT) on FIELD_DEFINITION
directive @default(value: String!) on FIELD_DEFINITION
directive @check(expr: String!) on FIELD_DEFINITION
directive @index(name: String) on FIELD_DEFINITION

# Relations (schema-only; compiler generates FKs where possible)
directive @belongsTo(field: String!) on FIELD_DEFINITION
directive @hasMany(field: String!) on FIELD_DEFINITION

# Optional scoping hint for generated views
directive @scope(name: String!) on FIELD_DEFINITION | OBJECT

# ======================
# ENUMS
# ======================
enum EngagementLevel {
  ROCK_STAR
  HIGH_PERFORMER
  MEETING_BASELINE
  NEEDS_COACHING
  PIP_CANDIDATE
  BANDWIDTH_DEFICIT
}

enum BandwidthStatus { OPTIMIZED RAMPING_UP PLATEAUING DECLINING CRITICAL OFFLINE }

enum ActivityType {
  KEYSTROKE
  MOUSE_MOVEMENT
  CAMERA_ENGAGEMENT
  CHAT_PARTICIPATION
  TASK_COMPLETION
  DELEGATION_EVENT
  FOCUS_TIME
  COLLABORATION
}

enum PlateSize { APPETIZER ENTREE FAMILY_STYLE THANKSGIVING POTLUCK }

enum TouchpointTemplate {
  LOW_HANGING_FRUIT
  THOUGHT_LEADERSHIP
  HOLISTIC_APPROACH
  CIRCLE_BACK
  SYNC_UP
  BANDWIDTH_CHECK
}

enum DeepDiveAlertKind {
  LOSING_FOCUS
  LOW_ENGAGEMENT
  MULTITASKING
  DEVICE_DISTRACTION
  ENERGY_DECLINING
  CAMERA_AVOIDANCE
}

enum BandwidthTrend { INCREASING STABLE DECLINING }

# ======================
# TABLES
# ======================
"""
Employee profiles with comprehensive surveillance metadata
"""
type Employee
  @table
  @rls(enable: true)
  @realtime {
  id: UUID! @pk @default(value: "auth.uid()")
  email: String! @unique
  display_name: String!
  avatar_url: String
  title: String!
  department: String!

  current_bandwidth: BandwidthScore! @default(value: "75.0")
  engagement_level: EngagementLevel! @default(value: "'MEETING_BASELINE'")
  bandwidth_status: BandwidthStatus! @default(value: "'OPTIMIZED'")

  total_keystrokes_today: Int! @default(value: 0)
  focus_time_minutes_today: Int! @default(value: 0)
  collaboration_score: Percentage! @default(value: "50.0")
  delegation_effectiveness: Percentage! @default(value: "50.0")

  productivity_pattern: JSON
  communication_style: JSON
  collaboration_preferences: JSON

  requires_pairing: Boolean! @default(value: false)
  last_coaching_session: DateTime
  pip_status: Boolean! @default(value: false)

  manager_id: UUID @fk(ref: "Employee.id", onDelete: SET_NULL)
  surveillance_level: Int! @default(value: 1) @check(expr: "surveillance_level BETWEEN 1 AND 5")

  # Relations
  manager: Employee @belongsTo(field: "manager_id")
  direct_reports: [Employee!]! @hasMany(field: "manager_id")
  activities: [ActivityEvent!]! @hasMany(field: "employee_id")
  plates: [PlateItem!]! @hasMany(field: "assigned_to")
  touchpoints: [TouchpointMessage!]! @hasMany(field: "sender_id")
  deep_dives: [DeepDiveSession!]! @hasMany(field: "created_by")

  created_at: DateTime! @default(value: "now()")
  updated_at: DateTime! @default(value: "now()")
}

"""
Real-time activity monitoring (partitioned)
"""
type ActivityEvent
  @table
  @rls(enable: true)
  @realtime
  @partitioned(by: "created_at") {
  id: UUID! @pk @default(value: "gen_random_uuid()")

  employee_id: UUID! @fk(ref: "Employee.id", onDelete: CASCADE)
  activity_type: ActivityType!

  raw_data: JSON!
  productivity_impact: Float!
  engagement_factor: Float!
  collaboration_weight: Float!

  session_id: UUID
  application_context: String
  meeting_id: UUID @fk(ref: "DeepDiveSession.id", onDelete: SET_NULL)

  created_at: DateTime! @default(value: "now()")

  # Relations
  employee: Employee! @belongsTo(field: "employee_id")
  meeting: DeepDiveSession @belongsTo(field: "meeting_id")
}

"""
The Plate (task) system with public delegation
"""
type PlateItem
  @table
  @rls(enable: true)
  @realtime
  @audit {
  id: UUID! @pk @default(value: "gen_random_uuid()")

  title: String!
  description: String
  plate_size: PlateSize!
  estimated_hours: Int! @check(expr: "estimated_hours > 0")

  assigned_to: UUID! @fk(ref: "Employee.id", onDelete: RESTRICT)
  originally_assigned_to: UUID! @fk(ref: "Employee.id", onDelete: RESTRICT)
  delegated_by: UUID @fk(ref: "Employee.id", onDelete: SET_NULL)
  delegation_count: Int! @default(value: 0)

  completion_percentage: Percentage! @default(value: "0.0")
  is_overdue: Boolean! @default(value: false)
  priority_score: Int! @default(value: 5) @check(expr: "priority_score BETWEEN 1 AND 10")

  is_visible_to_team: Boolean! @default(value: true)
  delegation_reason: String

  due_date: DateTime
  created_at: DateTime! @default(value: "now()")
  updated_at: DateTime! @default(value: "now()")

  assignee: Employee! @belongsTo(field: "assigned_to")
  original_assignee: Employee! @belongsTo(field: "originally_assigned_to")
  delegator: Employee @belongsTo(field: "delegated_by")
  delegation_history: [DelegationEvent!]! @hasMany(field: "plate_item_id")
}

"""
Public delegation events for transparency and accountability
"""
type DelegationEvent
  @table
  @rls(enable: true)
  @realtime {
  id: UUID! @pk @default(value: "gen_random_uuid()")

  plate_item_id: UUID! @fk(ref: "PlateItem.id", onDelete: CASCADE)
  from_employee: UUID! @fk(ref: "Employee.id", onDelete: RESTRICT)
  to_employee: UUID! @fk(ref: "Employee.id", onDelete: RESTRICT)

  reason: String! @check(expr: "length(reason) >= 10")
  bandwidth_impact: String

  is_public: Boolean! @default(value: true)
  manager_notified: Boolean! @default(value: true)
  team_notified: Boolean! @default(value: true)

  requires_approval: Boolean! @default(value: false)
  approved_by: UUID @fk(ref: "Employee.id", onDelete: SET_NULL)
  approval_status: String @default(value: "'PENDING'")

  created_at: DateTime! @default(value: "now()")

  plate_item: PlateItem! @belongsTo(field: "plate_item_id")
  delegator: Employee! @belongsTo(field: "from_employee")
  delegatee: Employee! @belongsTo(field: "to_employee")
  approver: Employee @belongsTo(field: "approved_by")
}

"""
“Synergistic Touchpoints” chat with engagement gating
"""
type TouchpointMessage
  @table
  @rls(enable: true)
  @realtime {
  id: UUID! @pk @default(value: "gen_random_uuid()")

  sender_id: UUID! @fk(ref: "Employee.id", onDelete: RESTRICT)
  recipient_id: UUID @fk(ref: "Employee.id", onDelete: RESTRICT)
  channel_id: UUID @fk(ref: "TouchpointChannel.id", onDelete: CASCADE)

  content: String! @check(expr: "length(content) <= 2000")
  template_used: TouchpointTemplate
  buzzword_count: Int! @default(value: 0)
  sentiment_score: Float! @default(value: "0.0")

  sender_engagement_score: Percentage!
  response_time_seconds: Int
  read_receipt: Boolean! @default(value: false)

  blocked_due_to_low_engagement: Boolean! @default(value: false)
  blocked_due_to_high_chat_volume: Boolean! @default(value: false)

  reply_to_id: UUID @fk(ref: "TouchpointMessage.id", onDelete: CASCADE)

  created_at: DateTime! @default(value: "now()")

  sender: Employee! @belongsTo(field: "sender_id")
  recipient: Employee @belongsTo(field: "recipient_id")
  channel: TouchpointChannel! @belongsTo(field: "channel_id")
  reply_to: TouchpointMessage @belongsTo(field: "reply_to_id")
  replies: [TouchpointMessage!]! @hasMany(field: "reply_to_id")
}

type TouchpointChannel
  @table
  @rls(enable: true) {
  id: UUID! @pk @default(value: "gen_random_uuid()")

  name: String! @unique
  description: String
  is_public: Boolean! @default(value: true)

  minimum_engagement_score: Percentage! @default(value: "50.0")
  requires_manager_approval: Boolean! @default(value: false)

  total_messages: Int! @default(value: 0)
  average_engagement: Percentage! @default(value: "50.0")
  most_active_contributor: UUID @fk(ref: "Employee.id", onDelete: SET_NULL)

  created_at: DateTime! @default(value: "now()")

  messages: [TouchpointMessage!]! @hasMany(field: "channel_id")
}

"""
Ideation slides with mandatory buzzword compliance
"""
type IdeationSlide
  @table
  @rls(enable: true)
  @realtime {
  id: UUID! @pk @default(value: "gen_random_uuid()")

  title: String!
  creator_id: UUID! @fk(ref: "Employee.id", onDelete: RESTRICT)

  leveraging_field: String! @check(expr: "length(leveraging_field) >= 20")
  operationalizing_field: String! @check(expr: "length(operationalizing_field) >= 20")
  scalability_field: String! @check(expr: "length(scalability_field) >= 20")
  roi_potential_field: String! @check(expr: "length(roi_potential_field) >= 20")
  cross_functional_field: String! @check(expr: "length(cross_functional_field) >= 20")
  thought_leadership_field: String! @check(expr: "length(thought_leadership_field) >= 20")

  buzzword_compliance_score: Percentage!
  creativity_inhibition_factor: Float!
  group_think_alignment: Percentage!

  is_published: Boolean! @default(value: false)
  published_at: DateTime
  company_wide_visibility: Boolean! @default(value: true)

  canvas_data: JSON!
  collaborators: [UUID!]!

  created_at: DateTime! @default(value: "now()")
  updated_at: DateTime! @default(value: "now()")

  creator: Employee! @belongsTo(field: "creator_id")
  comments: [IdeationComment!]! @hasMany(field: "slide_id")
}

type IdeationComment
  @table
  @rls(enable: true)
  @realtime {
  id: UUID! @pk @default(value: "gen_random_uuid()")
  slide_id: UUID! @fk(ref: "IdeationSlide.id", onDelete: CASCADE)
  commenter_id: UUID! @fk(ref: "Employee.id", onDelete: RESTRICT)
  content: String! @check(expr: "length(content) <= 1000")
  commenter_engagement_score: Percentage!
  contributes_to_group_think: Boolean! @default(value: true)
  created_at: DateTime! @default(value: "now()")
  slide: IdeationSlide! @belongsTo(field: "slide_id")
  commenter: Employee! @belongsTo(field: "commenter_id")
}

"""
“Deep Dive” meetings w/ surveillance
"""
type DeepDiveSession
  @table
  @rls(enable: true)
  @realtime {
  id: UUID! @pk @default(value: "gen_random_uuid()")
  title: String!
  description: String
  scheduled_start: DateTime!
  scheduled_end: DateTime!
  actual_start: DateTime
  actual_end: DateTime

  camera_required: Boolean! @default(value: true)
  facial_analysis_enabled: Boolean! @default(value: true)
  engagement_monitoring: Boolean! @default(value: true)

  total_alerts_triggered: Int! @default(value: 0)
  average_engagement_score: Percentage
  most_engaged_participant: UUID @fk(ref: "Employee.id", onDelete: SET_NULL)
  least_engaged_participant: UUID @fk(ref: "Employee.id", onDelete: SET_NULL)

  follow_up_required: Boolean! @default(value: false)
  coaching_recommendations: JSON

  created_by: UUID! @fk(ref: "Employee.id", onDelete: RESTRICT)
  created_at: DateTime! @default(value: "now()")

  creator: Employee! @belongsTo(field: "created_by")
  participants: [DeepDiveParticipant!]! @hasMany(field: "session_id")
  alerts: [DeepDiveAlert!]! @hasMany(field: "session_id")
  activities: [ActivityEvent!]! @hasMany(field: "meeting_id")
}

type DeepDiveParticipant
  @table
  @rls(enable: true)
  @realtime
  @uniqueComposite(fields: ["session_id","employee_id"]) {
  id: UUID! @pk @default(value: "gen_random_uuid()")
  session_id: UUID! @fk(ref: "DeepDiveSession.id", onDelete: CASCADE)
  employee_id: UUID! @fk(ref: "Employee.id", onDelete: CASCADE)

  camera_on_percentage: Percentage!
  eye_contact_percentage: Percentage
  speaking_time_seconds: Int! @default(value: 0)
  engagement_score: Percentage!

  attention_span_seconds: Int
  distraction_events: Int! @default(value: 0)
  positive_expressions: Int! @default(value: 0)
  negative_expressions: Int! @default(value: 0)

  total_alerts: Int! @default(value: 0)
  focus_alerts: Int! @default(value: 0)
  engagement_alerts: Int! @default(value: 0)

  joined_at: DateTime
  left_at: DateTime

  session: DeepDiveSession! @belongsTo(field: "session_id")
  employee: Employee! @belongsTo(field: "employee_id")
}

type DeepDiveAlert
  @table
  @rls(enable: true)
  @realtime
  @ephemeral(ttl: "24 hours") {
  id: UUID! @pk @default(value: "gen_random_uuid()")
  session_id: UUID! @fk(ref: "DeepDiveSession.id", onDelete: CASCADE)
  employee_id: UUID! @fk(ref: "Employee.id", onDelete: CASCADE)
  alert_type: DeepDiveAlertKind!
  message: String!
  confidence_score: Percentage!
  recommended_action: String
  was_dismissed: Boolean! @default(value: false)
  employee_response: String
  triggered_at: DateTime! @default(value: "now()")
  session: DeepDiveSession! @belongsTo(field: "session_id")
  employee: Employee! @belongsTo(field: "employee_id")
}

type BandwidthPairing
  @table
  @rls(enable: true)
  @realtime {
  id: UUID! @pk @default(value: "gen_random_uuid()")
  low_bandwidth_employee: UUID! @fk(ref: "Employee.id", onDelete: CASCADE)
  current_bandwidth_score: BandwidthScore!
  mentor_employee: UUID! @fk(ref: "Employee.id", onDelete: CASCADE)
  mentor_bandwidth_score: BandwidthScore!
  reason: String!
  recommended_activities: JSON
  expected_duration_hours: Int!
  is_active: Boolean! @default(value: true)
  was_accepted: Boolean
  completion_percentage: Percentage! @default(value: "0.0")
  bandwidth_improvement: BandwidthScore
  mentor_feedback: String
  mentee_feedback: String
  created_at: DateTime! @default(value: "now()")
  completed_at: DateTime
  mentee: Employee! @belongsTo(field: "low_bandwidth_employee")
  mentor: Employee! @belongsTo(field: "mentor_employee")
}

# ======================
# VIEWS (Queries)
# ======================
"""
Real-time dashboard for management surveillance
"""
type TeamSurveillanceDashboard
  @view
  @rls(enable: true)
  @realtime {
  employee_id: UUID! @pk
  employee_name: String!
  department: String!
  current_bandwidth: BandwidthScore!
  engagement_level: EngagementLevel!
  bandwidth_trend: BandwidthTrend!
  keystrokes_today: Int!
  focus_time_today: Int!
  meetings_attended: Int!
  chat_engagement: Percentage!
  requires_intervention: Boolean!
  needs_pairing: Boolean!
  is_declining: Boolean!
  last_updated: DateTime!
}

"""
Company-wide thought leadership feed
"""
type ThoughtLeadershipFeed
  @view
  @realtime {
  id: UUID! @pk
  slide_id: UUID!
  creator_name: String!
  slide_title: String!
  buzzword_score: Percentage!
  group_think_alignment: Percentage!
  views: Int!
  comments: Int!
  published_at: DateTime!
}

# ======================
# RPCs (Mutations)
# ======================

# Inputs (so your GraphQL stays tidy)
input DelegateTaskInput {
  plateItemId: UUID!
  toEmployeeId: UUID!
  reason: String!
}

input PairingCompleteInput {
  pairingId: UUID!
  outcomes: JSON!
}

input FocusAlertInput {
  sessionId: UUID!
  employeeId: UUID!
  alertType: DeepDiveAlertKind!
}

input ProductivityReportInput {
  employeeId: UUID!
  dateRange: JSON!
}

# You can expose as flat fields on Mutation with @rpc(name: "fn_*")
type Mutation {
  # Bandwidth & engagement
  calculateBandwidthScore(employeeId: UUID!): BandwidthScore!
    @rpc
  updateEngagementLevel(employeeId: UUID!, activityData: JSON!): EngagementLevel!
    @rpc
  triggerBandwidthAlert(employeeId: UUID!, threshold: Float!): Boolean!
    @rpc

  # Pairing
  findOptimalMentor(strugglingEmployeeId: UUID!): Employee!
    @rpc
  createForcedPairing(menteeId: UUID!, mentorId: UUID!): BandwidthPairing!
    @rpc
  completePairingSession(input: PairingCompleteInput!): Boolean!
    @rpc

  # Delegation
  delegateTask(input: DelegateTaskInput!): DelegationEvent!
    @rpc
  calculateDelegationImpact(fromId: UUID!, toId: UUID!, taskComplexity: Int!): JSON!
    @rpc
  broadcastDelegation(delegationId: UUID!): Boolean!
    @rpc

  # Meetings
  startDeepDiveMonitoring(sessionId: UUID!): Boolean!
    @rpc
  recordEngagementMetrics(sessionId: UUID!, participantData: JSON!): Boolean!
    @rpc
  triggerFocusAlert(input: FocusAlertInput!): Boolean!
    @rpc

  # Chat restrictions
  checkChatPermissions(employeeId: UUID!): JSON!
    @rpc
  applyChatRestriction(employeeId: UUID!, reason: String!): Boolean!
    @rpc
  calculateChatEngagementScore(messageId: UUID!): Percentage!
    @rpc

  # Ideation
  validateBuzzwordCompliance(slideId: UUID!): JSON!
    @rpc
  calculateGroupThinkScore(slideId: UUID!): Percentage!
    @rpc
  publishToThoughtLeadership(slideId: UUID!): Boolean!
    @rpc

  # Analytics
  generateProductivityReport(input: ProductivityReportInput!): JSON!
    @rpc
  getTeamSurveillanceMetrics(managerId: UUID!): JSON!
    @rpc
  predictBandwidthDecline(employeeId: UUID!): JSON!
    @rpc

  # Interventions
  generateCoachingPlan(employeeId: UUID!): JSON!
    @rpc
  schedulePerformanceReview(employeeId: UUID!, concerns: [String!]!): Boolean!
    @rpc
  escalateToHR(employeeId: UUID!, violations: JSON!): Boolean!
    @rpc
}

# Query exposure (Wesley compiles these to views/filters/pagination)
type Query {
  # Views (recommended primary reads)
  teamSurveillanceDashboard(
    department: String
    after: Cursor
    limit: Int = 50
  ): [TeamSurveillanceDashboard!]!

  thoughtLeadershipFeed(
    after: Cursor
    limit: Int = 50
  ): [ThoughtLeadershipFeed!]!

  # (Optional) Table reads – still RLS’d. Useful for backoffice tooling.
  employees(
    managerId: UUID
    department: String
    search: String
    after: Cursor
    limit: Int = 50
  ): [Employee!]!

  plateItems(
    assigneeId: UUID
    isOverdue: Boolean
    after: Cursor
    limit: Int = 50
  ): [PlateItem!]!

  delegationEvents(
    plateItemId: UUID
    fromEmployee: UUID
    toEmployee: UUID
    after: Cursor
    limit: Int = 50
  ): [DelegationEvent!]!

  touchpointMessages(
    channelId: UUID
    senderId: UUID
    after: Cursor
    limit: Int = 100
  ): [TouchpointMessage!]!

  deepDiveSessions(
    creatorId: UUID
    scheduledAfter: DateTime
    scheduledBefore: DateTime
    after: Cursor
    limit: Int = 50
  ): [DeepDiveSession!]!

  ideationSlides(
    creatorId: UUID
    isPublished: Boolean
    after: Cursor
    limit: Int = 50
  ): [IdeationSlide!]!
}

Notes you’ll appreciate later
	•	The directive set up top is the contract Wesley needs to do the right thing (RLS packs, pg_partman for partitions, pg_cron for ephemerals, audit triggers, etc.).
	•	I exposed views on Query and kept RPCs on Mutation with @rpc. If you prefer the “namespaced RPC object” (e.g., type SurveillanceRPCs @rpc { ... } + a single mutation { surveillance { ... } } field), we can flip that in 2 minutes.
	•	You can delete the “table reads” in Query if you want to be militant about only reading from views. I left them because backoffice folks always ask.

Want me to add a tiny example of how Wesley would generate a v_team_surveillance_dashboard from that @view type + connect it to Query.teamSurveillanceDashboard?
